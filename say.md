## page2
大家知道 下面这连个图标 都是什么软件的图标吗？

对，solr 和  elastic search
他们两个都是基于lucene实现全文索引功能

## page 3
下面我们看下Lucene的工作流程
简单地说，他帮助我们创建索引文件，


## page 4
主要分为两部分：创建索引和查询索引
左边 把原始文档 变成索引的过程，
右边
Lucene 的大致工作流程其实就是这样
## page 5
正式开始前，我们先解决第一个问题
why? 全文索引能够解决什么问题？
## page 6
  我们先看一个例子

  表格中的数据类似数据库的一个表，每一行就像数据库的一首诗的记录。
  查找时根据id定位到这行数据，从而拿到这首诗的信息。
  当然数据量大时 我们会创建数据库索引，一般是b+树结构索引。这种索引形式称之为正排索引
  
  对数值 和 文本 都能添加 这种正排索引。 
## page 7 
  正排索引对数值或数值范围查询性能和效果很好，但如果是文本查询就会有很大的局限性：
  
## page 8 
  这时候以Lucene为代表的倒排索引就起作用了。
  
  这种按照词搜索到文档的结构称为倒排索引，跟正排索引差不多是相反的过程，因此得名。

## page 9
  图表中根据词定位 文档
  左边的部分 是 词典的索引，就相当于词典的目录

  中间的部分是词典，再根据他定位到这些词的 定位到右边的数据

  右边的部分是一个有序的文档id数组，称之为倒排表；图中是包含词的 文档id
  真实情况还会有词频率，位置等，用于计算相关度；我们在此省略掉。

## page 10
我们再细化下查字典的过程。

我们输入一个词，定位到这个词的信息这部分称为词项索引
Lucene里词项索引 数据结构为FST

概念


## page 11
FST构建时是要按照字典序构建的

从root节点开始，到这个词结束

每条边后面的就代表一个状态。
有词的时候记录为有词状态， 走到最后表明完结状态。

因为共享前缀数据结构，才实现了节省空间

状态固定 概念 就是 当一个 边 及其后续 的不再会变化时，这个边就为固定状态，

此时可以序列化，进而固化到磁盘里。


## page 12
查找时，会依次找到合适的边 直到找到这个词，或者发现找不到  为止
有词的变就会记录 倒排表 的地址，下一步就可以查倒排表了。


## page 13
现在我们在对比下 hash和 fst的空间占用情况

同样是内存查询会比hash慢10倍，但hash占用太大不能放入内存；每次走磁盘IO就会慢的更多了。

而且fst这种状态结构还能实现模糊匹配的功能，hash就实现不了
比如任意字符 我们就会把当前 节点下的边都 走一遍，这样就能找到匹配的 或者 发现无匹配的了

举例： 比如，a*ple
## page 14 
字典查询处理后，下一步就到倒排表了

我们知道， 包含一个词 的 文档个数 可能会有数万或数百万，因此倒排表的数据量就会很大。
通过这些压缩编码方式，可以有效降低磁盘占用。
还有就是Lucene会大量使用缓存，缓存的压缩也会显著降低内存占用

像delta编码这种，只记录第一个文档id，后续就只记录与前一个id的差值

```讲图```
第一条数据 经过delta编码会节省一般的空间
而第二条因为首个数字就很大，导致没有节省空间


## page 15


图上这个简单的例子，编码后分块 第一块使用8个bit位存储一个数字，第二块使用5个bit位存储，
这样 合起来 就只用5个byte，另外还有每个块开头标记占用的1个byte，最终实现了从24byte 压缩到 7个byte。


Lucene实际使用中会更繁琐，还会进行分区（每个分区包含256个数），每个分区使用不同的位数，记录这个分区使用的位数。这样在刚才说的第二种情况下，压缩效果就会好一些。
。这个技术叫 Frame of Reference。

## page 16
了解delta这种对 数组数据编码的，如果单一数据我们可以使用Vint这种编码，
变长字节编码。


# page 17
我们知道为了加快搜索，Lucene大量使用了缓存；
对缓存进行压缩主要使用位图压缩的方法：用位的方式来表示，每个数字对应其中的一位，也就是我们常说的位图，bitmap。 它经常被作为索引用在数据库、查询引擎和搜索引擎中，并且位操作（如 and 求交集、or 求并集）之间可以并行，效率更好。

按位与 / 按位或 速度很快的。

```如图```


# page 18
为了解决这个问题，有了roaring bitset

Lucene 中的LRU 查询缓存对密度小于 1% 的集合使用RoaringDocIdSet (Lucene实现的Roaring Bitmaps)。否则，使用FixedBitSet 。

# page 19
读

# page 20


图中bitmap  container 使用65535位，也就是8kb, 代表 65535个数字
array container直接使用的就是数组。

## page 21
使用array container是随着数组数量增大而占用空间逐步变大
bitmap container 是固定的8kb
如果用数组存储int的方式 就需要 256Kb 
在存储满时 bitmap 是 数组 占用空间的32分之一
只有在要存储的 数组 占用小于 8kn时，使用数组 容器 才能节省空间
所以临界点数组使用超过8kb时改用bitmap


## page 22

了解了查询和压缩/编码，最后我们来看下索引的文件结构


读



最后我们再了解下他的索引文件


读表


所以 搜索时 会依次

查 tip 文件 看是否也这个词
查 tim 文件 找到 统计信息
查 doc 获取到倒排表。


# end
ok我们最后回顾下 今天讲的内容，一次讲解了 倒排索引的结构、fst的查询构建，编码、压缩方式，索引文件